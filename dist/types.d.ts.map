{"mappings":"AAAA;;GAEG;AAEH;IACE;;OAEG;IACH,GAAG,EAAE,MAAM,CAAC;IACZ;;OAEG;IACH,IAAI,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;IACrB;;;OAGG;IACH,YAAY,CAAC,EAAE,CAAC,GAAG,EAAE,MAAM,KAAK,IAAI,CAAA;CACrC;AAED,oBAAoB,MAAM,CAAC;AAC3B;;;;;GAKG;AACH,OAAO,MAAM,SAAS,YAA8B,CAAC;AAErD;;GAEG;AACH;IACE;;;;OAIG;IACH,KAAK,IAAI,EAAE,eAAe,EAAE,EAAE,EAAE,CAAC,GAAG,IAAI,EAAC,MAAM,EAAE,KAAK,OAAO,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;IAE7E;;;;;;OAMG;IACH,KAAK,IAAI,EAAE,KAAK,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;IAElD;;;;OAIG;IACH,WAAW,GAAG,EAAE,MAAM,GAAG,IAAI,CAAC;IAE9B;;;;;OAKG;IACH,SAAS,YAAY,CAAC;CACvB;AAWD;;;GAGG;AACH,OAAO,MAAM,yBAAwB,QA2EpC,CAAC;AAEF,QAAA,MAAM,eAAe,UAAoC,CAAC;AAC1D,OAAO,mBAtHM,eAAe,gBAAe,MAAM,EAAE,KAAK,QAAQ,MAAM,CAAC,KAAG,IAAI,eASjE,MAAM,MAAM,CAAC,KAAG,QAAQ,MAAM,MAAM,CAAC,CAAC,oBAOjC,MAAM,KAAG,IAsG4B,CAAC;AACxD,eAAe,eAAe,CAAC","sources":["source/source/tameable.ts","source/tameable.ts"],"sourcesContent":[null,"/**\n * Simple & small functional framework for tameing interdependent code\n */\n\ninterface SpecDescription {\n  /**\n   * String by which to refer to a spec'ed object\n   */\n  key: string,\n  /**\n   * Array of keys to depend on\n   */\n  deps?: Array<string>,\n  /**\n   * Called when an object becomes invalid (eg call `.destroy()`)\n   * @param obj Previously valid object that has been marked invalid.\n   */\n  invalidateFn?: (obj: object) => void\n};\n\ntype SuccessValue = object;\n/**\n * \n * Return `SUCCESS` when we only care about the side effects of the `fn` parameter when calling spec.\n * That is, `fn` doesn't produce an object for use elsewhere. Although using `SUCCESS` is more explicit, it's not required.\n * A dummy object is used of the form `{success: true}`. Can check for `SUCCESS` with `Object.is(SUCCESS, obj)`.\n */\nexport const SUCCESS: SuccessValue = {success: true};  // there can only be one\n\n/**\n * Simple & small functional framework for tameing interdependent code\n */\ninterface Tameable {\n  /**\n   * Describe how to construct an object, referenced by a key, perhaps depending on other speced objects\n   * @param desc set the key, dependancies, and other optional properties\n   * @param fn attempts to construct an object in a valid state and return that object or `SUCCESS`\n   */\n  spec(desc: SpecDescription, fn: (...objs:object[]) => Promise<object>): void,\n\n  /**\n   * Allow us to use spec'ed objects, knowing they will be in a valid state when we do\n   * if the objects are not valid, they will be recomputed in dependancy order before they are used\n   * for each dependancy key in deps, the function will be given a parameter contianing the corrisponding\n   * managed object. If you only care about side effects, a use function isn't mandatory\n   * @param deps array of keys to depend on\n   */\n  once(deps: Array<string>): Promise<Array<object>>,\n\n  /**\n   * Mark an object associated with `key` as invalid, to be reconstructed if it's needed again.\n   * All objects dependant on it are also invalidated\n   * @param key String by which to refer to a spec'ed object\n   */\n  invalidate(key: string): void,\n\n  /**\n   * Return `SUCCESS` when we only care about the side effects of `fn`, that is, it doesn't\n   * produce an object for use elsewhere. Check for `SUCCESS` with `Object.is(SUCCESS, obj)`.\n   * Although using `SUCCESS` is more explicit, it's not required.\n   * A dummy object is used of the form `{success: true}`.\n   */\n  SUCCESS: SuccessValue,\n};\n\n// Assuming bundlers will remove `if (DEBUG) ...` for production\nconst DEBUG = process.env.NODE_ENV !== 'production';\n\nconst INVALID = 'invalid';\nconst VALID = 'valid';\nconst VALIDATING = 'validating';\nconst INIT = 'uninitalised';\nconst ERROR = 'error';\n\n/**\n * Get an API with an isolated namespace. In other words, keys in this namespace (internally, a map) are kept seperate from the global keys (a different map).\n * For example, use this in a library to prevent namespace collisions with those who use the library. Otherwise, perfer the default global namespace.\n */\nexport const isolatedNamespace = (): Tameable => {\n  const namespace = new Map();\n\n  const validate = async (key: string): Promise<object> => {\n    const o = namespace.get(key);\n    if (o.state === VALID) return o.obj;\n    if (o.state === VALIDATING) return o.promise; // if this node is currently awaiting validation then await that promise instead of validating again\n    if (DEBUG && o.state === ERROR) throw Error(`'${key}' has a previous error\\nCheck your error handeling. Are you calling 'once' repeatadly and forgetting to await?`);\n    o.state = VALIDATING;\n    o.promise = Promise.all(o.deps.map(validate))  // make sure requirements met\n      .then(objs => o.fn(...objs));  // run function with requirements as arguments \n    o.obj = await o.promise;\n    o.promise = undefined;\n    if (o.obj === null || typeof o.obj !== 'object') {  // must be non-null object to be valid\n      o.state = ERROR;\n      if (DEBUG && o.obj === undefined)  // provide more helpful message if nothing returned by fn\n        throw Error(`did you forget to return an object for '${key}'?\\nuse \\`tame.SUCCESS\\` if returning nothing is intended`);\n      throw Error(`'${key}' failed to validate: expected non-null object, got '${o.obj}'`);\n    }\n    o.state = VALID;\n    return o.obj;\n  };\n\n  const invalidate = (key: string): void => {\n    if (DEBUG && !namespace.has(key)) throw Error(`'${key}' cannot be invalidated, it does not exist`);\n\n    const o = namespace.get(key);\n    if (o.state !== VALID) return;\n    o.state = INVALID;\n    o.invalidateFn?.(o.obj);\n    o.obj = undefined;  // remove reference to allow garbage collection\n    o.children.forEach(invalidate);\n  };\n\n  return {\n    spec(desc, fn) {\n      const {key, invalidateFn} = desc;\n      const deps = desc.deps ?? [];\n      if (DEBUG) {\n        if (!key) throw Error('spec objects require a key');\n        if (!(typeof key === 'string')) throw Error('key must be a string');\n        if (namespace.has(key)) throw Error(`key '${key}' is taken`);\n        for (const d of deps)  // enforce no cycles\n          if (!namespace.has(d)) throw Error(`'${d}' must exist before '${key}' can depend on it`);\n        if ((new Set(deps)).size !== deps.length) throw Error(`'${key}' has duplicate dependancies`);\n        if (typeof fn !== 'function') throw Error(`'${key}' must have a function that returns an object`);\n      }\n\n      for (const d of deps) namespace.get(d).children.push(key);\n      namespace.set(key, {\n        deps,  // always Array\n        invalidateFn,  // might be undefined, called when invalidated for the first time\n        fn,\n        children: [],\n        state: INIT,\n        // obj: undefined,  // will have a value returned by fn when state === VALID\n        // promise: undefined,  // if this node is currently awaiting validation then await this promise instead of validating again\n      });\n    },\n\n    async once(deps) {\n      if (DEBUG) {\n        if (!(deps instanceof Array)) throw Error('\\'once\\' requires an array of dependancies (strings)');\n        for (const d of deps)\n          if (!namespace.has(d)) throw Error(`'${d}' must exist before 'once' can depend on it`);\n        if ((new Set(deps)).size !== deps.length) throw Error('\\'once\\' has duplicate dependancies');\n      }\n\n      return Promise.all(deps.map(validate));   // make sure requirements met, valid objects returned\n    },\n\n    invalidate,\n\n    SUCCESS,\n  };\n};\n\nconst globalNamespace = /*#__PURE__*/ isolatedNamespace();\nexport const {spec, once, invalidate} = globalNamespace;\nexport default globalNamespace;\n"],"names":[],"version":3,"file":"types.d.ts.map","sourceRoot":"../"}