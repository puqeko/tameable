{"mappings":"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","sources":["source/tameable.ts"],"sourcesContent":["/**\n * Simple & small functional framework for tameing interdependent code\n */\n\ninterface SpecDescription {\n  /**\n   * String by which to refer to a spec'ed object\n   */\n  key: string,\n  /**\n   * Array of keys to depend on\n   */\n  deps?: Array<string>,\n  /**\n   * Called when an object becomes invalid (eg call `.destroy()`)\n   * @param obj Previously valid object that has been marked invalid.\n   */\n  invalidateFn?: (obj: object) => void\n};\n\ntype SuccessValue = object;\n/**\n * \n * Return `SUCCESS` when we only care about the side effects of the `fn` parameter when calling spec.\n * That is, `fn` doesn't produce an object for use elsewhere. Although using `SUCCESS` is more explicit, it's not required.\n * A dummy object is used of the form `{success: true}`. Can check for `SUCCESS` with `Object.is(SUCCESS, obj)`.\n */\nexport const SUCCESS: SuccessValue = {success: true};  // there can only be one\n\n/**\n * Simple & small functional framework for tameing interdependent code\n */\ninterface Tameable {\n  /**\n   * Describe how to construct an object, referenced by a key, perhaps depending on other speced objects\n   * @param desc set the key, dependancies, and other optional properties\n   * @param fn attempts to construct an object in a valid state and return that object or `SUCCESS`\n   */\n  spec(desc: SpecDescription, fn: (...objs:object[]) => Promise<object>): void,\n\n  /**\n   * Allow us to use spec'ed objects, knowing they will be in a valid state when we do\n   * if the objects are not valid, they will be recomputed in dependancy order before they are used\n   * for each dependancy key in deps, the function will be given a parameter contianing the corrisponding\n   * managed object. If you only care about side effects, a use function isn't mandatory\n   * @param deps array of keys to depend on\n   */\n  once(deps: Array<string>): Promise<Array<object>>,\n\n  /**\n   * Mark an object associated with `key` as invalid, to be reconstructed if it's needed again.\n   * All objects dependant on it are also invalidated\n   * @param key String by which to refer to a spec'ed object\n   */\n  invalidate(key: string): void,\n\n  /**\n   * Return `SUCCESS` when we only care about the side effects of `fn`, that is, it doesn't\n   * produce an object for use elsewhere. Check for `SUCCESS` with `Object.is(SUCCESS, obj)`.\n   * Although using `SUCCESS` is more explicit, it's not required.\n   * A dummy object is used of the form `{success: true}`.\n   */\n  SUCCESS: SuccessValue,\n};\n\n// Assuming bundlers will remove `if (DEBUG) ...` for production\nconst DEBUG = process.env.NODE_ENV !== 'production';\n\nconst INVALID = 'invalid';\nconst VALID = 'valid';\nconst VALIDATING = 'validating';\nconst INIT = 'uninitalised';\nconst ERROR = 'error';\n\n/**\n * Get an API with an isolated namespace. In other words, keys in this namespace (internally, a map) are kept seperate from the global keys (a different map).\n * For example, use this in a library to prevent namespace collisions with those who use the library. Otherwise, perfer the default global namespace.\n */\nexport const isolatedNamespace = (): Tameable => {\n  const namespace = new Map();\n\n  const validate = async (key: string): Promise<object> => {\n    const o = namespace.get(key);\n    if (o.state === VALID) return o.obj;\n    if (o.state === VALIDATING) return o.promise; // if this node is currently awaiting validation then await that promise instead of validating again\n    if (DEBUG && o.state === ERROR) throw Error(`'${key}' has a previous error\\nCheck your error handeling. Are you calling 'once' repeatadly and forgetting to await?`);\n    o.state = VALIDATING;\n    o.promise = Promise.all(o.deps.map(validate))  // make sure requirements met\n      .then(objs => o.fn(...objs));  // run function with requirements as arguments \n    o.obj = await o.promise;\n    o.promise = undefined;\n    if (o.obj === null || typeof o.obj !== 'object') {  // must be non-null object to be valid\n      o.state = ERROR;\n      if (DEBUG && o.obj === undefined)  // provide more helpful message if nothing returned by fn\n        throw Error(`did you forget to return an object for '${key}'?\\nuse \\`tame.SUCCESS\\` if returning nothing is intended`);\n      throw Error(`'${key}' failed to validate: expected non-null object, got '${o.obj}'`);\n    }\n    o.state = VALID;\n    return o.obj;\n  };\n\n  const invalidate = (key: string): void => {\n    if (DEBUG && !namespace.has(key)) throw Error(`'${key}' cannot be invalidated, it does not exist`);\n\n    const o = namespace.get(key);\n    if (o.state !== VALID) return;\n    o.state = INVALID;\n    o.invalidateFn?.(o.obj);\n    o.obj = undefined;  // remove reference to allow garbage collection\n    o.children.forEach(invalidate);\n  };\n\n  return {\n    spec(desc, fn) {\n      const {key, invalidateFn} = desc;\n      const deps = desc.deps ?? [];\n      if (DEBUG) {\n        if (!key) throw Error('spec objects require a key');\n        if (!(typeof key === 'string')) throw Error('key must be a string');\n        if (namespace.has(key)) throw Error(`key '${key}' is taken`);\n        for (const d of deps)  // enforce no cycles\n          if (!namespace.has(d)) throw Error(`'${d}' must exist before '${key}' can depend on it`);\n        if ((new Set(deps)).size !== deps.length) throw Error(`'${key}' has duplicate dependancies`);\n        if (typeof fn !== 'function') throw Error(`'${key}' must have a function that returns an object`);\n      }\n\n      for (const d of deps) namespace.get(d).children.push(key);\n      namespace.set(key, {\n        deps,  // always Array\n        invalidateFn,  // might be undefined, called when invalidated for the first time\n        fn,\n        children: [],\n        state: INIT,\n        // obj: undefined,  // will have a value returned by fn when state === VALID\n        // promise: undefined,  // if this node is currently awaiting validation then await this promise instead of validating again\n      });\n    },\n\n    async once(deps) {\n      if (DEBUG) {\n        if (!(deps instanceof Array)) throw Error('\\'once\\' requires an array of dependancies (strings)');\n        for (const d of deps)\n          if (!namespace.has(d)) throw Error(`'${d}' must exist before 'once' can depend on it`);\n        if ((new Set(deps)).size !== deps.length) throw Error('\\'once\\' has duplicate dependancies');\n      }\n\n      return Promise.all(deps.map(validate));   // make sure requirements met, valid objects returned\n    },\n\n    invalidate,\n\n    SUCCESS,\n  };\n};\n\nconst globalNamespace = /*#__PURE__*/ isolatedNamespace();\nexport const {spec, once, invalidate} = globalNamespace;\nexport default globalNamespace;\n"],"names":[],"version":3,"file":"module.js.map","sourceRoot":"../"}